<html>

<head>
  <title>Testing</title>
  <script
  src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.2/jquery.min.js"></script>
</head>


<body>
  <canvas id="main"></canvas>
  <script>

  const width = 1000;
  const height = 1000;

  const gridWidth = 4;

  var grid = [];
  var per = [];
  for (var i = 0; i <= gridWidth; i++){
    per.push([]);
  }
  var smoothed = [];
  for (var i = 0; i < gridWidth; i++){
    smoothed.push([]);
  }

  const p = [ 151,160,137,91,90,15,         // Hash lookup table as defined by Ken Perlin.  This is a randomly
    131,13,201,95,96,53,194,233,7,225,140,36,
    103,30,69,142,8,99,37,240,21,10,23,190,6,         // arranged array of all numbers from 0-255 inclusive.
    148,247,120,234,75,0,26,197,62,94,252,219,
    203,117,35,11,32,57,177,33,88,237,149,56,
    87,174,20,125,136,171,168,68,175,74,165,
    71,134,139,48,27,166,77,146,158,231,83,111,
    229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,
    102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208,
    89,18,169,200,196,135,130,116,188,159,86,164,100,
    109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,
    147,118,126,255,82,85,212,207,206,59,227,47,16,
    58,17,182,189,28,42,223,183,170,213,119,248,152,
    2,44,154,163,70,221,153,101,155,167,43,172,9,
    129,22,39,253,19,98,108,110,79,113,224,232,178,185,
    112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,
    81,51,145,235,249,14,239,107,49,192,214, 31,181,199,106,157,184,
    84,204,176,115,121,50,45,127,4,150,254,
    138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180];

  //  Basic smoothing
  function smooth(x, y){

    var xPrev = (x-1<0) ? gridWidth-1 : x-1;
    var xNext = (x+1>=gridWidth) ? 0 : x+1;

    var yPrev = (y-1<0) ? gridWidth-1 : y-1;
    var yNext = (y+1>=gridWidth) ? 0 : y+1;


    corners = ( grid[xPrev][yPrev]+grid[xNext][yPrev]+grid[xPrev][yNext]+grid[xNext][yNext]
        ) / 16;
    sides = ( grid[xPrev][y]+grid[xNext][y]+grid[x][yNext]+grid[x][yNext]
        ) / 8;
    centre = grid[x][y]/4;

    smoothed[x][y] = corners + sides + centre;
  }


  function randVector(){
    var angle = Math.random()*2*Math.PI;
    return {x: Math.cos(angle), y: Math.sin(angle)};
    //return Math.random();
  }

  function lerp(a, b, x){
    return a + x * (b-a);
  }

  function fade(t){
    return t * t * t * (t * (t * 6 - 15) + 10); // 6t^5 - 15t^4 + 10t^3
  }

  function perlin2(x, y, size){
    var total = 0;
    var octaves = 1;
    var persistence = 0.5;
    var norm = 0;
    
    for (var i = 0; i < octaves; i++){
      var f = Math.pow(2, i);
      var a = Math.pow(persistence, i);
      norm += a;

      //var div = size;
      var div = 1;
      var mult = gridWidth;
      var ix, iy;
      //ix = ix 
      //if (Math.floor(x * f / div) >= gridWidth-1 || Math.floor(y * f /
      //div) >= gridWidth-1) break;
      total += interpolateNoise(x * f * mult / div, y * f * mult / div) * a;
      //total += interpolateNoise(x , y) * a;
    }
    /*
    var xx, yy;
    xx = Math.floor(x*gridWidth);
    yy = Math.floor(y*gridWidth);
    total = smoothed[xx][yy];
    */
    //total = interpolateNoise(x * gridWidth, y * gridWidth);
    //console.log(total);
    //console.log(norm);
    return total / norm;

  }

  function interpolateNoise(x, y){
    var intx = Math.floor(x);
    var intx_suc = intx+1;
    var inty = Math.floor(y);
    var inty_suc = inty+1;

    var fracx = x - intx;
    var fracy = y - inty;

    intx = intx % gridWidth;
    intx_suc = intx_suc % gridWidth;
    inty = inty % gridWidth;
    inty_suc = inty_suc % gridWidth;

    var i1 = lerp(smoothed[intx][inty], smoothed[intx_suc][inty], fracx);
    var i2 = lerp(smoothed[intx][inty_suc], smoothed[intx_suc][inty_suc], fracx);

    var ret = lerp(i1, i2, fracy);
    //  DELETE ME
    //ret = smoothed[intx][inty];
    //
    return ret;
  }

  

  function generatePerlin(){
    //  Init grid
    for (var x = 0; x <= gridWidth; x++){
      var col = [];
      for (var y = 0; y <= gridWidth; y++){
        //col.push(randVector());
        col.push(Math.random());
      }
      grid.push(col);
    }
    for (var x = 0; x < gridWidth; x++){
      for (var y = 0; y < gridWidth; y++){
        smooth(x, y);

      }
    }

    for (var x = 1; x < gridWidth-1; x++){
      for (var y = 1; y < gridWidth-1; y++){
        //per[x][y] = perlin2(x,y);

      }
    }

  }
  function makeRGB(b){
    var n = Math.floor(b * 255);
    var s = n.toString();
    return "rgb(" + s + "," + s + "," + s + ")";
  }
  function drawPerlin(){

    
    //const octaves = 1;

    //const amp = 0.5;
    var canvas = $("#main")[0];
    canvas.width = width;
    canvas.height = height;
    var ctx = canvas.getContext("2d");

    const renderWidth = 256;
    const renderMult = 1;
    const seaHue = 222;
    const seaSat = 49;
    const landHue = 94;
    const landSat = 45;
    const sealevel = 0.55;

    for (var y = 0; y < renderWidth ; y++){
      for (var x = 0; x < renderWidth ; x++){
        ctx.translate(x*renderMult,y*renderMult);

        var l = perlin2(x/renderWidth, y/renderWidth);
        //var l = 0;
        //var l = smoothed[x][y];
        if (l > sealevel){
          var c = "hsl("+landHue.toString() + ", " + landSat.toString() +
            "%, " + (l*100).toString() +"%)";
        }
        else{
          var c = "hsl("+seaHue.toString() + ", " + seaSat.toString() +
          "%, " + (l*100).toString() +"%)";
        }
        ctx.fillStyle = c;


        ctx.fillRect(0,0,renderMult,renderMult);
        ctx.translate(-x*renderMult, -y*renderMult);
      }
    }
    //ctx.fillStyle = "black";
    //ctx.fillRect(0,0, 1000, 1000);
  }

  console.log("Working...");
  generatePerlin();
  console.log("Done");
  drawPerlin();
  console.log("Drawn");
  </script>
</body>


</html>
